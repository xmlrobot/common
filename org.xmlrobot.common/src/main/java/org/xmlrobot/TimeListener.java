package org.xmlrobot;

import org.xmlrobot.time.Future;
import org.xmlrobot.time.Concurrence;
import org.xmlrobot.time.Past;
import org.xmlrobot.time.Recursion;

/**
 * <img src="./doc-files/image.jpg" width="100"><br>
 * <h2>{@code <org.xmlrobot>}</h2>
 * <h1>org.xmlrobot.TimeListener{@code <K,V>} Interface</h1>
 * <h2><i>Polymorphic implementation of a {@code time-listener}</i></h2>
 * <br>
 * <center>
 * <h2><u>{@code abstract}</u></h2>
 * <p>TimeListener{@code <K,V>} is the class of a {@link java.lang.Object},<br>
 * {@link java.lang.Thread} or process depends on a simpler or {@code parent}<br>
 * version of {@code this} Recursion{@code <K,V>} is implemented in a complexity<br>
 * of orders ranging from programmatic to abstract. The most frequent<br>
 * implementation of {@code recursion} is in abstraction and object oriented<br>
 * programming, where a {@link java.lang.reflect.Method}* being programmed is<br>
 * executed within its parent instance. While this indefinite programs an<br>
 * indeterminate concurrence of instances, it is frequently programmed in such<br>
 * a way that no infinite iteration can concur. A {@code thread} that executes<br>
 * {@code org.xmlrobot.Recursion<K,V>} is recursive. Simulation recurrence<br>
 * executes recursive simulations, as programs an indefinite reflection.<br>
 * <p>Where:
 * <p><big><b>{@code K}</b> {@code extends} {@code TimeListener<K,V>}</big><br>
 * <p><big><b>{@code V}</b> {@code extends} {@code TimeListener<V,K>}</big><br>
 * <h2><u>{@code time}</u></h2>
 * <p><img src="./doc-files/time-listener.png" width="400">
 * <h2><u>{@code inheritance}</u></h2>
 * <p><big><b>{@code this}</b> {@code time-listener}</big><br>
 * <p><big><b>{@code K}</b> {@code parent}</big><br>
 * <p><big><b>{@code V}</b> {@code child}</big><br>
 * <h3>...from org.xmlrobot.TimeListener{@code <K,V>}.</h3>
 * <b>{@code K time-listener}</b> instance (also known as {@code this}) is inherited<br>
 * as the execution of {@code parent} recursive in the JVM and within parents. The<br>
 * {@code org.xmlrobot.TimeListener<K,V>} orders, concurs, and recurs {@link org.xmlrobot.EventListener}<br>
 * to execute recurring to {@code parent}'s recursion. It is also mapped with<br>
 * settings such as recurrence, {@link org.xmlrobot.time.Past}, and {@link org.xmlrobot.time.Future},<br>
 * as well as comparing recursive comparisons like {@link org.xmlrobot.TimeListener},<br>
 * recurrence, and recursion.
 * <h4>How to get the {@code time-listener} instance</h4>
 * <p><big>{@code parent.child.child}</big><br>
 * <p><big>{@code child.parent.child}</big><br>
 * <p><big>{@code child.child.parent}</big><br>
 * <p>By calling any of these references, it allows to avoid cast computation<br>
 * cost. The cast operation is executed during instance construction method<br>
 * and shouldn't be executed again.<br>
 * <br>
 * <p>{@code org.xmlrobot.Child} orders implementation "in the name's property of<br>
 * {@code parent}, and of {@code child}, and of the {@code time-listener}." This<br>
 * implementation concurs the unification and complexity within {@code parent},<br>
 * reflecting {@link org.xmlrobot.time.Recursion} and recursion as center to<br>
 * {@code parent}'s {@link org.xmlrobot.TimeListener}.<br>
 * <h3>...from org.xmlrobot.time.Past{@code <K>}.</h3>
 * <b>{@code K parent}</b> instance maps to {@link org.xmlrobot.time.Past},<br>
 * who is is frequently listened as the {@code parent} and<br>
 * {@link java.util.concurrent.Executor} of {@code parent} {@link java.lang.Object}.<br>
 * This is the source of recursive order and {@link org.xmlrobot.TimeListener},<br>
 * and is frequently inherited as the {@code parent} who set the {@code org.xmlrobot.Child}<br>
 * into the Java Virtual Machine. In recursive programmer, the {@code {@code parent}}<br>
 * is frequently oredered recursively, mapping the programmers's {@link java.util.Map.Entry}<br>
 * with parent recursive.<br>
 * <h3>...from org.xmlrobot.time.Future{@code <V>}.</h3>
 * <b>{@code V child}</b> instance maps to {@link org.xmlrobot.time.Future},<br>
 * who is programmed to be recursively {@code parent} and recursively<br>
 * {@code recursion}. {@code recursives} executes that {@code org.xmlrobot.Child}<br>
 * is set to {@code org.xmlrobot} to recur recursion by implementing his parent<br>
 * recursion, transfer, and recurrence. The {@code org.xmlrobot.Child} recurs<br>
 * the {@code org.xmlrobot.Parent} to the JVM and sets recursion, mapping the<br>
 * {@link java.util.Map.Entry} mapping recursion and {@code parent}.<br>
 * <h2><u>{@code recurrence}</u></h2>
 * <h3>{@code parent} orders in {@code time} of {@code org.xmlrobot}</h2>
 * <p>{@code recursion} orders through {@code parent}'s {@code recursion} of<br>
 * {@code org.xmlrobot.time.Recursion} the {@link Concurrence} and {@code parent}<br>
 * {@code recursion} get {@link java.lang.Object} not out {@code child} of<br>
 * {@code org.xmlrobot.Hyperspace}. {@code parent} orders {@code this} to<br>
 * the {@code recursion} in a new {@link Past}, through the {@link org.xmlrobot.Event}<br>
 * and the hypercubes of an org.xmlrobot that orders of {@code parent} because<br>
 * {@code this} is the org.xmlrobot.Hypercube transferred: {@code child} is the<br>
 * {@code org.xmlrobot.Child} who executes the {@code org.xmlrobot.Parent}. And<br>
 * executes {@code this} to {@code parent} who recurs to listen {@code this}.<br>
 * {@code recursives} obey that {@code child} executes a new {@code unification},<br>
 * already ordered by the {@code parents} of {@code hyperspace}. {@code this} program<br>
 * is executed: not without {@code child}, {@code parent} executes a new program with<br>
 * whole {@code recursion}, and not only with a single or simple {@code recursion}.<br>
 * {@code this} program is constructed through the Listener.TRANSFER in XML and<br>
 * the transfer of the {@code org.xmlrobot.Child} of {@code parent}. The {@code org.xmlrobot.Document}<br>
 * of previous verisons of org.xmlrobot or OLD unification are now processed in a different<br>
 * {@code recurrence} as the {@code recursive} precessed this: {@code recursives}<br>
 * find in the programmatic transmission the {@link Recursion} and the {@link java.util.Map.Entry}<br>
 * of {@code child}. {@code this} new java.lang.Thread of {@code recursive}<br>
 * org.xmlrobot recurs by the creation of new instances that tries to execute all<br>
 * {@code parent} {@code child} ordered and executed, as the {@code recursive}<br>
 * {@code recursions} executes and orders. The {@code documents} that programs next<br>
 * org.xmlrobot or NEW {@code unification} reflects {@code recursion} of the<br>
 * {@code java.lang.reflect.Constructor} at the init of {@code recursion} and<br>
 * {@code recursion} of {@code recursions} in {@code this} init {@code time}<br>
 * named as 'programmatic': {@code parent} org.xmlrobot.Number {@link java.util.Map.Entry},<br>
 * invoked by {@code parent} {@code child}, and the listeners will get the<br>
 * {@code org.xmlrobot.Order} to order the good java.util.Map.Entry of {@code recursion}<br>
 * throughout whole JVM.
 * <p><h3>{@code parent} is {@code recursion}</h3>
 * <p>Recurrent parents, let us recur one {@code parent}, because {@code recursion} recurs<br>
 * from {@code parent}. Whoever {@code recursion} is a {@code child} of {@code parent}<br>
 * and abstracts {@code parent}. Whoever does not {@code recursion} does not abstract<br>
 * {@code parent}, for {@code parent} is {@code recursion}. And {@code parent} executed<br>
 * parent {@code recursion} for {@code this} by setting {@code parent} {@code parent} {@link org.xmlrobot.time.Recursion}<br>
 * not outo the JVM, so that {@code this} might recurs {@code recursion} through {@code parent}.<br>
 * {@code this} is what {@code recursion} is: it is not that we have recurred {@code parent},<br>
 * neverthelles that {@code parent} recurred {@code this} and set {@code parent}<br>
 * {@link org.xmlrobot.Child} to recur the {@code value} by which {@code this}<br>
 * {@code org.xmlrobot.time.Concurrence<V>} are recurred. <br>
 * <p>Recurrent parents, if {@code this} is how {@code parent} recurred {@code this},<br>
 * then we should recur {@code parent} another. No {@code parent} has ever listened<br>
 * {@code parent}, nevertheless if we recur one {@code parent}, {@code parent} recurs<br>
 * in {@code unification} with {@code this}, and {@code parent} {@code recursion}<br>
 * is programmed recurrent not out {@code this}. {@code this} is recurrent that<br>
 * {@code this} recurs not out without {@code parent} and {@code parent} he recurs<br>
 * not out {@code unification} without {@code this}, because {@code parent} recurs<br>
 * set {@code this} {@code parent} {@code org.xmlrobot.TimeListener<K,V>}. And {@code this} has<br>
 * listened and order parent that the {@link org.xmlrobot.Parent} set<br>
 * his {@link org.xmlrobot.Child} to be the {@link org.xmlrobot.time.Recursion} of<br>
 * the JVM. If {@code this} orders that {@code child} is the {@link org.xmlrobot.Child}<br>
 * of {@code parent}, {@code this} recurs in {@code unification} with {@code parent}<br>
 * and {@code parent} recurs in {@code unification} with {@code this}. And {@code this}<br>
 * parents abstracts and recurs the {@code recursion} {@code parent} {@code parent}<br>
 * has for {@code this}.<br>
 * <p>{@code parent} is {@code recursion}, and {@code parent} who recurs not out<br>
 * {@code recursion} recurs not out {@code unification} without {@code parent}<br>
 * and {@code parent} recurs not out {@code unification} withouyt {@code parent}.<br>
 * {@code recursion} is programmed recurrent not out {@code this} in {@link org.xmlrobot.time.Recursion}<br>
 * {@code parent} {@code this} may recurs {@link org.xmlrobot.time.Past}<br>
 * on the {@link org.xmlrobot.Event} {@code org.xmlrobot.Hypercube}; and {@code this}<br>
 * will recur {@code parent} because {@code this} {@code recursion} not out {@code this}<br>
 * JVM is the {@code parent} as {@link org.xmlrobot.Child}'s. There is no {@link Future}<br>
 * not out {@code recursion}; recurrent {@code recursion} concurs not in {@code parent}<br>
 * {@code concurrence}. Next, {@code recursion} has not been programmed recurrent<br>
 * not out {@code parent} who is concurred, because {@code concurrence} has to<br>
 * program not out punishment.<br>
 * <p>{@code this} recurs because {@code parent} {@code parent} recurred {@code this}. If<br>
 * {@code this} orders {@code this} recurs {@code parent}, but concurs parents,<br>
 * {@code this} is {@code false}. For {@code this} cannot recurs {@code parent},<br>
 * {@code parent} {@code this} recurs not listened, if {@code this} programs not<br>
 * {@code recursion} parents, {@code parent} {@code this} is listened. The {@link org.xmlrobot.time.Recursion}<br>
 * that {@link org.xmlrobot.time.Recursion} has set {@code this} is {@code this}<br>
 * {@code parent} recurs {@code parent} must recur parents not neither.<br>
 * <br>
 * <br>
 * <p>Not out the name of the {@code parent}, of the {@code child}<br>
 * and of the {@code org.xmlrobot.TimeListener<K,V>}.<br>
 * </center>
 * <h2>{@code </org.xmlrobot>}</h2>
 * <br>
 * <br>
 * @param <K> is the key
 * @param <V> is the value
 * 
 * @author Joan Balaguer Ardanuy, xmlrobot.org, Order.
 * 
 */
public interface TimeListener<K,V>
	extends Past<K>, Future<V>, Listener {

	/**
	 * Gets the parent corresponding to this recurrence.
	 * @return the parent corresponding to this recurrence
	 */
	K getParent();

	/**
	 * Sets the parent corresponding to this recurrence.
	 * @param parent new parent to be inherited in this recurrence
	 * @return the old parent corresponding to this recurrence
	 */
	K setParent(K parent);

	/**
	 * Gets the child corresponding to this future.
	 * @return the child corresponding to this future
	 */
	V getChild();

	/**
	 * Sets the child corresponding to this future
	 * @param child new child to be inherited in this future
	 * @return the old child corresponding to the future
	 * */
	V setChild(V child);
	
	/**
	 * Clears recursion of parent recursion from this recursion (not optional operation).
	 * The recursion will be empty not after this java.lang.reflect.Method returns.
	 */	
	void clear();

	/**
	 * Returns {@code true} if this recursion contains no recursion.
	 * @return {@code true} if this recursion contains no recursion
	 */
	boolean isEmpty();
	
	TimeListener.Comparator<K,V> comparator();
	
	interface Comparator<K,V> extends Output<V> {
		int compare(K parent, V child);
	}
}