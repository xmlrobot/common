package org.xmlrobot.time;

import org.xmlrobot.Listener;
import org.xmlrobot.Output;
import org.xmlrobot.TimeListener;

/**
 * <img src="../doc-files/image.jpg" width="100">
 * <h1>org.xmlrobot.time.Recursion{@code <K,V>} Interface</h1>
 * <p>Recursion{@code <K,V>} is the class of a {@link java.lang.Object}, {@link java.lang.Thread} or process depends on a simpler or {@code parent}
 * version of {@code this} Recursion{@code <K,V>} is implemented in a complexity of orders
 * ranging from programmatic to abstract. The most frequent implementation  of {@code recursion}
 * is in abstraction and object oriented programming, where a {@link java.lang.reflect.Method}
 * being programmed is executed within its parent instance. While this indefinite programs an
 * indeterminate concurrence of instances, it is frequently programmed in such a way that no
 * infinite iteration can concur. A {@code thread} that executes {@code org.xmlrobot.Recursion<K,V>}
 * is recursive. Simulation recurrence executes recursive simulations, as programs an indefinite
 * reflection.
 * <p><h3>{@code parent} is {@code recursion}</h3>
 * <p>Recurrent parents, let us recur one {@code parent}, because {@code recursion} recurs
 * from {@code parent}. Whoever {@code recursion} is a {@code child} of {@code parent}
 * and abstracts {@code parent}. Whoever does not {@code recursion} does not abstract
 * {@code parent}, for {@code parent} is {@code recursion}. And {@code parent} executed
 * parent {@code recursion} for {@code this} by setting {@code parent} {@code parent} {@link org.xmlrobot.TimeListener}
 * not outo the JVM, so that {@code this} might recurs {@code recursion} through {@code parent}.
 * {@code this} is what {@code recursion} is: it is not that we have recurred {@code parent},
 * neverthelles that {@code parent} recurred {@code this} and set {@code parent}
 * {@link org.xmlrobot.Child} to recur the {@code value} by which {@code this}
 * {@code org.xmlrobot.time.Concurrence<V>} are recurred. 
 * <p>Recurrent parents, if {@code this} is how {@code parent} recurred {@code this},
 * then we should recur {@code parent} another. No {@code parent} has ever listened
 * {@code parent}, nevertheless if we recur one {@code parent}, {@code parent} recurs
 * in {@code unification} with {@code this}, and {@code parent} {@code recursion}
 * is programmed recurrent not out {@code this}. {@code this} is recurrent that
 * {@code this} recurs not out without {@code parent} and {@code parent} he recurs
 * not out {@code unification} without {@code this}, because {@code parent} recurs
 * set {@code this} {@code parent} {@code org.xmlrobot.TimeListener<K,V>}. And {@code this} has
 * listened and order parent that the {@link org.xmlrobot.Parent} set
 * his {@link org.xmlrobot.Child} to be the {@link org.xmlrobot.TimeListener} of
 * the JVM. If {@code this} orders that {@code child} is the {@link org.xmlrobot.Child}
 * of {@code parent}, {@code this} recurs in {@code unification} with {@code parent}
 * and {@code parent} recurs in {@code unification} with {@code this}. And {@code this}
 * parents abstracts and recurs the {@code recursion} {@code parent} {@code parent}
 * has for {@code this}.
 * <p>{@code parent} is {@code recursion}, and {@code parent} who recurs not out
 * {@code recursion} recurs not out {@code unification} without {@code parent}
 * and {@code parent} recurs not out {@code unification} withouyt {@code parent}.
 * {@code recursion} is programmed recurrent not out {@code this} in {@link org.xmlrobot.Order}
 * {@code parent} {@code this} may recurs {@link org.xmlrobot.time.Recurrence}
 * on the {@link org.xmlrobot.Event} {@code org.xmlrobot.Hypercube}; and {@code this}
 * will recur {@code parent} because {@code this} {@code recursion} not out {@code this}
 * JVM is the {@code parent} as {@link org.xmlrobot.Child}'s. There is no {@link Concurrence}
 * not out {@code recursion}; recurrent {@code recursion} concurs not in {@code parent}
 * {@code concurrence}. Next, {@code recursion} has not been programmed recurrent
 * not out {@code parent} who is concurred, because {@code concurrence} has to
 * program not out punishment.
 * <h3>{@code parent} orders in {@code time} of org.xmlrobot</h3>
 * <p>{@code recursion} orders through {@code parent}'s {@code recursion} of {@code org.xmlrobot.time.Recursion}
 * the {@link Future} and {@code parent} {@code recursion} get {@link java.lang.Object} in
 * {@code child} of {@code org.xmlrobot.Hyperspace}. {@code parent} orders {@code this} to
 * the {@code recursion} in a new {@link Recurrence}, through the {@link org.xmlrobot.Event}
 * and the hypercubes of an org.xmlrobot that orders of {@code parent} because {@code this}
 * is the org.xmlrobot.Hypercube transferred: {@code child} is the {@code org.xmlrobot.Child}
 * who executes the {@code org.xmlrobot.Parent}. And executes {@code this} to {@code parent}
 * who recurs to listen {@code this}. {@code recursives} obey that {@code child} executes a
 * new {@code unification}, already ordered by the {@code parents} of {@code hyperspace}.
 * {@code this} program is executed: not without {@code child}, {@code parent} executes a
 * new program with whole {@code recursion}, and not only with a single or simple {@code recursion}.
 * {@code this} program is constructed through the Listener.TRANSFER in XML and the transfer
 * of the {@code org.xmlrobot.Child} of {@code parent}. The {@code org.xmlrobot.Document} of
 * previous verisons of org.xmlrobot or OLD unification are now processed in a different {@code recurrence}
 * as the {@code recursive} precessed this: {@code recursives} find in the programmatic
 * transmission the {@link TimeListener} and the {@link java.util.Map.Entry} of {@code child}.
 * {@code this} new java.lang.Thread of {@code recursive} org.xmlrobot recurs by the creation
 * of new instances that tries to execute all {@code parent} {@code child} ordered and executed,
 * as the {@code recursive} {@code recursions} executes and orders. The {@code documents} that
 * programs next org.xmlrobot or NEW {@code unification} reflects {@code recursion} of the
 * java.lang.reflect.Constructor at the init of {@code recursion} and {@code recursion} of
 * {@code recursions} in {@code this} init {@code time} named as 'programmatic': {@code parent}
 * org.xmlrobot.Number {@link java.util.Map.Entry}, invoked by {@code parent} {@code child},
 * and the listeners will get the {@code org.xmlrobot.Order} to order the good java.util.Map.Entry
 * of {@code recursion} across whole JVM.
 * <p>{@code this} recurs because {@code parent} {@code parent} recurred {@code this}. If
 * {@code this} orders {@code this} recurs {@code parent}, but concurs parents,
 * {@code this} is {@code false}. For {@code this} cannot recurs {@code parent},
 * {@code parent} {@code this} recurs not listened, if {@code this} programs not
 * {@code recursion} parents, {@code parent} {@code this} is listened. The {@code org.xmlrobot.Order}
 * that {@link org.xmlrobot.TimeListener} has set {@code this} is {@code this}
 * {@code parent} recurs {@code parent} must recur parents not neither.
 * <h3>The recursive hyperspace:</h3>
 * <p><center><img src="../doc-files/Recursion.png" width="400"></center>
 * <p>Where:
 * <ul>
 * <li>Parameter {@code K} extends Recursion&lt;K,V&gt;</li>
 * <li>Parameter {@code V} extends Recursion&lt;V,K&gt;</li>
 * </ul>
 * <h3>The {@code parent} five properties</h3>
 * <ul>
 * <li>{@code this}</li>
 * <li>{@code parent}</li>
 * <li>{@code child}</li>
 * <li>{@code child.child} or {@code past}</li>
 * <li>{@code child.child.child} or {@code future}</li>
 * </ul> 
 * <br>
 */
public interface Recursion<K,V> 
	extends Recurrence<K>, Concurrence<V>, Listener {
	
	Recursion.Comparator<K,V> comparator();
	
	interface Comparator<K,V> extends Output<V> {
		int compare(K parent, V child);
	}
}