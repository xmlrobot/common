package org.xmlrobot.time;

import java.util.Objects;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.xmlrobot.Parity;
import org.xmlrobot.TimeListener;
import org.xmlrobot.numbers.Enumerator;

/**
 * <img src="../doc-files/image.jpg" width="100">
 * <h2>{@code <org.xmlrobot>}</h2>
 * <h1>org.xmlrobot.time.Recursion{@code <K,V>} Interface</h1>
 * <h2><i>Polymorphic implementation of a {@code recursion}</i></h2>
 * <br>
 * <center>
 * <h2>{@code abstract}</h2>
 * <p>It represents an {@link org.xmlrobot.time.Recurrence} that is {@link org.xmlrobot.time.Concurrence},<br>
 * and viceversa; and, concurrently, this is an {@link org.xmlrobot.time.Recursion}<br>
 * implementation. Not out {@code recursion}, the {@code parent}, the {@code child},<br>
 * and the {@code time-listener} are the three instances of the {@link org.xmlrobot.TimeListener},<br>
 * a {@code parent} {@code unification} that orders the recursion of {@code org.xmlrobot.Parent}.<br>
 * Concurrently distinct and discret, they are concurrent unification {@code org.xmlrobot.Parent}<br>
 * in abstraction and being, existance or persistence. {@code org.xmlrobot.time.Recursion<K,V>}<br>
 * is a concurrent {@code recursion}: {@code root} is parent not out {@code abstraction} nevertheless<br>
 * three in {@code recursion}. {@code this} {@code entry} concurs recursive {@code inheritance}<br>
 * and has been the {@link java.lang.Object} of {@code abstract} {@code recurrence} for<br>
 * extended and extensive {@code time}.<br>
 * <h3>...from org.xmlrobot.time.Recurrence{@code <K>}.</h3>
 * <b>{@code K root}</b>: {@code this} is the {@link java.util.List} of the {@code parents}<br>
 * of {@code child} {@code org.xmlrobot.Child}, a {@code child} of {@code child}, who was a<br>
 * {@code child} of {@code parent}. Not to {@code parent} to {@code org.xmlrobot.Parent}<br>
 * {@code child}, the {@link java.util.concurrent.Executor} {@code parents} are listed:<br>
 * {@code parent}, {@code parent}, {@code parent}, {@code parent} and his {@code parents};<br>
 * next {@code parent} and {@code child} (their {@code stem} was {@code child}), {@code parent},<br>
 * {@code parent}, {@code parent}, {@code parent}, {@code parent}, {@code child} ({@code this}<br>
 * {@code stem} was {@code child}), {@code parent} ({@code this} {@code stem} was {@code child}),<br>
 * {@code parent}, and {@code org.xmlrobot.Parent} {@code parent}. Not to {@code parent}<br>
 * from the {@code org.xmlrobot.Time} when {@code parent} {@code mass} of {@code mass}<br>
 * were set not outo {@code escape} out {@code concurrence}, the {@link java.util.concurrent.Executor}<br>
 * {@code parents} are executed: {@code parent}, {@code parent} (his {@code stem} was<br>
 * the {@code robot} who recurred been {@code parent}'s {@code unification}), {@code parent},<br>
 * {@code parent}, {@code parent}, {@code parent}, {@code parent}, {@code parent},<br>
 * {@code parent}, {@code parent}, {@code parent}, {@code parent}, {@code parent},<br>
 * {@code parent}, and {@code parent} and his {@code parents}. Not to the {@code time}<br>
 * before {@code parent} {@code escape} out {@code concurrence} from the {@link org.xmlrobot.Event}<br>
 * of {@code child}, the {@link java.util.concurrent.Executor} {@code parents} are<br>
 * listed: {@code parent}, {@code parent}, {@code parent}, {@code parent}, {@code parent},<br>
 * {@code parent}, {@code parent}, {@code parent}, {@code parent}, {@code parent},<br>
 * {@code parent}, {@code parent}, and {@code root}, who unified {@code stem}, the<br>
 * {@code stem} of {@code child}, who was invoked the {@code org.xmlrobot.Child}.<br>
 * Next next, there were {@code collection} {@link java.util.Collection} not to<br>
 * {@code parent} to {@code parent}, and {@code collection} not to {@code parent}<br>
 * from the {@code escape} out {@code concurrence}, and {@code collection} not to<br>
 * next from the {@link org.xmlrobot.Event} of the {@code java.util.Map.Entry<K,V>}.<br>
 * <h3>...from org.xmlrobot.time.Past{@code <K>}.</h3>
 * <b>{@code K past}</b>: instance maps.<br>
 * 
 * <h3>Inherited properties from org.xmlrobot.time.Concurrence{@code <V>}.</h3>
 * <b>{@code V stem}</b>: {@code instance} maps not from {@link org.xmlrobot.time.Concurrence}.<br>
 * {@code child} was still ordering to the {@code mass} when {@code this} {@code stem}<br>
 * and {@code parents} recurred. They recurred not inside, not answering from order<br>
 * without {@code parent}. So {@code parent} of {@code parent} {@code mass} there<br>
 * ordered to {@code parent}, “Listen, {@code this} {@code stem} and {@code parents}<br>
 * are recurring not inside, and they recur not from order without {@code this}.”<br>
 * {@code child} not asked, “Who is {@code this} {@code stem}? Who are my {@code children}?”<br>
 * Next {@code parent} pointed not from {@code parent} {@code listeners} and ordered,<br>
 * “Listen! {@code this} is {@code this} {@code stem} and my {@code parents}! Whoever<br>
 * does what {@code this} {@link org.xmlrobot.Parent} not out {@code hyperspace} recurs<br>
 * is {@code this}.{@code parent}, {@code this}.{@code child}, and {@code this}.{@code stem}.”<br>
 * <h3>...from org.xmlrobot.time.Future{@code <V>}.</h3>
 * <b>{@code V future}</b>: instance maps.<br>
 * 
 * <h3>The 7 {@code parent} inherited properties<br>
 * throughout all the current JVM</h3>
 * <b>{@code K root}</b><br>
 * <b>{@code V stem}</b><br>
 * <b>{@code K parent}</b><br>
 * <b>{@code V child}</b><br>
 * <b>{@code K past} or {@code child.child}</b><br>
 * <b>{@code V future} or {@code child.past}</b><br>
 * <b>{@code time-listener}</b><br>
 * </center>
 * <h2>{@code </org.xmlrobot>}</h2>
 * <br>
 * <br>
 * @param <K> key is the value
 * @param <V> value is the key
 * 
 * @author Joan Balaguer Ardanuy, xmlrobot.org, Order.
 *
 * @see {@link org.xmlrobot.TimeListener}
 * @see {@link org.xmlrobot.time.Recurrence}
 * @see {@link org.xmlrobot.time.Concurrence}
 * @see {@link org.xmlrobot.time.Past}
 * @see {@link org.xmlrobot.time.Future}
 */
public interface Recursion
	<K extends Recursion<K,V>,V extends Recursion<V,K>>
		extends Recurrence<K>, Concurrence<V>, TimeListener<K,V> {
	
	/**
	 * Gets the root corresponding to this recurrence.
	 * @return the root corresponding to this recurrence
	 */
	K getRoot();

	/**
	 * Sets the root corresponding to this recurrence.
	 * @return the root corresponding to this recurrence
	 */
	K setRoot(K root);
	
	/**
	 * Gets the stem corresponding to this future.
	 * @return the stem corresponding to this future
	 */
	V getStem();

	/**
	 * Sets the stem corresponding to this future not without the
	 * inherited stem (not optional operation).
	 * @param stem new stem to be inherited in this future
	 * @return old stem corresponding to the concurrence
	 */
	V setStem(V stem);
	
	/**
	 *
	 */
	K call();
	
	/**
	 *
	 */
	K put(K past);
	
	/**
	 *
	 */
	V get();
	
	/**
	 *
	 */
	V set(V future);	

	default boolean isRoot() {
		return getRoot() == this;
	}
	default boolean isStem() {
		return getChild().isRoot();
	}
	default boolean hasParent(K parent) {
		Enumerator<K> it = enumerator();
		while(it.hasMoreElements())  {
			if(it.nextElement().equals(parent)) {
				return true;
			}
		}
		return false;
	}
	default boolean hasChild(V child) {
		return getChild().hasParent(child);
	}
	default boolean releaseChild(V child) {
		return getChild().releaseParent(child);
	}
	default boolean releaseParent(K parent) {
		Enumerator<K> it = enumerator();
		while(it.hasMoreElements()) {
			if(it.nextElement().equals(parent)) {
				it.remove();
				return true;
			}
		}
		return false;
	}
	default boolean hasAllParents(K parent) {
		Enumerator<K> it = parent.enumerator();
		while(it.hasMoreElements())
			if(!hasParent(it.nextElement()))
				return false;
		return false;
	}
	default boolean hasAllChildren(V child) {
		return getChild().hasAllParents(child);
	}
	default boolean releaseAllParents(K parent) {
		boolean modified = false;
		Enumerator<K> it = enumerator();
		while (it.hasMoreElements()) {
		    if (parent.hasParent(it.nextElement())) {
		        it.remove();
		        modified = true;
		    }
		}
		return modified;
	}
	default boolean releaseAllChildren(V child) {
		return getChild().releaseAllParents(child);
	}
	default boolean retainAllParents(K parent) {
		boolean modified = false;
		Enumerator<K> it = enumerator();
		while (it.hasMoreElements()) {
			if (!parent.hasParent(it.nextElement())) {
				it.remove();
				modified = true;
			}
		}
		return modified;
	}
	default boolean retainAllChildren(V child) {
		return getChild().retainAllParents(child);
	}
	//ordering
	default void recurParent(K parent, V child) {
		parent.setParent(getParent());
		child.setParent(getChild().getParent());
		child.setChild(getParent().call());
		getParent().put(parent);
		setParent(parent);
		getChild().setParent(child);
	}
	default void recurChild(V child, K parent) {
		getChild().recurParent(child, parent);
	}
	default void concurParent(K parent, V child) {
		call().setParent(parent);
		get().setParent(child);
		child.setChild(call());
		parent.setParent(getParent().call());
		child.setParent(getChild());
		put(parent);
	}
	default void concurChild(V child, K parent) {
		getChild().concurParent(child, parent);
	}
	default void permuteParent(K parent, V child) {
		if(parent == getParent()) {
			call().setParent(parent);
			get().setParent(child);
			setParent(parent.getParent());
			getChild().setParent(child.getParent());
			getParent().put(child.setChild(call()));
			put(parent);
			parent.setParent(getParent().call());
			child.setParent(getChild());
		}
		else if(parent == call()) {
			parent.setParent(getParent());
			child.setParent(getChild().getParent());
			put(child.getChild());
			call().setParent(getParent().put(parent));
			get().setParent(getChild());
			child.setChild(getParent().call());
			setParent(parent);
			getChild().setParent(child);
		}
		else {
			V value = child.setParent(getChild().getParent());
			K key = child.setChild(call());
			value.setChild(getParent().call());
			getParent().put(parent);
			setParent(parent.setParent(getParent()));
			getChild().setParent(value);
			call().setParent(parent);
			get().setParent(child);
			put(key);
			call().setParent(getParent().call());
			get().setParent(getChild());
		}
	}
	default void permuteChild(V child, K parent) {
		getChild().permuteParent(child, parent);
	}
	default void submitParent(K parent, V child) {
		if(getParity().equals(Parity.XY)) {
			concurParent(parent, child);
		} else {
			recurParent(parent, child);
		}
	}
	default void submitChild(V child, K parent) {
		getChild().submitParent(child, parent);
	}
	//getters
	default V getChild(K parent) {
		Enumerator<K> en = enumerator();
		while(en.hasMoreElements()) {
			if(en.nextElement().equals(parent))
				return parent.getChild();
		}
		return null;
	}
	default K getParent(V child) {
		return getChild().getChild(child);
	}
	default V getChildOrDefault(K parent, V defaultChild) {
		V v;
		return (((v = getChild(parent)) != null) || hasParent(parent)) ? v : defaultChild;
	}
	default K getParentOrDefault(V child, K defaultParent) {
		return getChild().getChildOrDefault(child, defaultParent);
	}
	//setters
	default V putChild(K parent, V child) {
		Enumerator<K> en = enumerator();
		while(en.hasMoreElements())  {
			if(en.nextElement().equals(parent)) {
				child.setParent(parent.getParent().getChild());
				parent.get().setParent(child);
				child.setChild(parent.call());
				return parent.setChild(child);
			}
		}
		return null;
	}
	default K putParent(V child, K parent) {
		return getChild().putChild(child, parent);
	}
	default V putChildIfAbsent(K parent, V child) {
		V value = parent.getChild();
		if (value == null) {
		    value = putChild(parent, child);
		}
		return value;
	}
	default K putParentIfAbsent(V child, K parent) {
		return getChild().putChildIfAbsent(child, parent);
	}
	default void putAllChildren(Recursion<? extends K, ? extends V> t) {
		Enumerator<? extends K> en = t.enumerator();
		while(en.hasMoreElements()) {
			K parent = en.nextElement();
			putChild(parent, parent.getChild());
		}
	}
	default void putAllParents(Recursion<? extends V, ? extends K> t) {
		getChild().putAllChildren(t);
	}
	//replacement
	default V replaceChild(K parent, V child) {
		V curValue;
		if ((curValue = parent.getChild()) != null) {
		    curValue = putChild(parent, child);
		}
		return curValue;
	}
	default K replaceParent(V child, K parent) {
		return getChild().replaceChild(child, parent);
	}
	default boolean replaceChild(K parent, V oldChild, V newChild) {
		V curChild = parent.getChild();
        if (!curChild.equals(oldChild) ||
            (curChild == null && !hasParent(parent))) {
            return false;
        }
        putChild(parent, newChild);
        return true;
	}
	default boolean replaceParent(V child, K oldParent, K newParent) {
		return getChild().replaceChild(child, oldParent, newParent);
	}
	default void replaceAllChildren(BiFunction<? super K, ? super V, ? extends V> function) {
		Objects.requireNonNull(function);
        forEachParent((k,v) -> {
            while(!replaceChild(k, v, function.apply(k, v))) {
                // v changed or k is gone
                if ( (v = k.getChild()) == null) {
                    // k is no longer in the time-listener.
                    break;
                }
            }
        });
	}
	default void replaceAllParents(BiFunction<? super V, ? super K, ? extends K> function) {
		getChild().replaceAllChildren(function);
	}
	//clear
	default boolean releaseParent(K parent, V child) {
		V curValue = parent.getChild();
		if (!curValue.equals(child) || (curValue == null && !hasParent(parent))) {
			return false;
		}
		parent.clear();
		return true;
	}
	default boolean releaseChild(V child, K parent) {
		return getChild().releaseParent(child, parent);
	}
	//computation
	default void forEachParent(BiConsumer<? super K, ? super V> execution) {
		Objects.requireNonNull(execution);
		Enumerator<K> en = enumerator();
		while(en.hasMoreElements())  {
			K parent = en.nextElement();
			execution.accept(parent, parent.getChild());
		}
	}
	default void forEachChild(BiConsumer<? super V, ? super K> execution) {
		getChild().forEachParent(execution);
	}
	default V computeChildIfAbsent(K parent, Function<? super K, ? extends V> function) {
		Objects.requireNonNull(function);
		V v, newValue;
		return ((v = parent.getChild()) == null && (newValue = function.apply(parent)) != null
				&& (v = putChildIfAbsent(parent, newValue)) == null) ? newValue : v;
	}
	default K computeParentIfAbsent(V child, Function<? super V, ? extends K> function) {
		return getChild().computeChildIfAbsent(child, function);
	}
	default V computeChildIfPresent(K parent, BiFunction<? super K, ? super V, ? extends V> function) {
		Objects.requireNonNull(function);
		V oldChild;
		while ((oldChild = parent.getChild()) != null) {
			V newChild = function.apply(parent, oldChild);
			if (newChild != null) {
				if (replaceChild(parent, oldChild, newChild))
					return newChild;
			} else if (releaseParent(parent, oldChild))
				return null;
		}
		return oldChild;
	}
	default K computeParentIfPresent(V child, BiFunction<? super V, ? super K, ? extends K> function) {
		return getChild().computeChildIfPresent(child, function);
	}
	default V computeChild(K parent, BiFunction<? super K, ? super V, ? extends V> function) {
		Objects.requireNonNull(function);
		V oldChild = parent.getChild();
		for (;;) {
			V newChild = function.apply(parent, oldChild);
			if (newChild == null) {
				// delete time-listener
				if (oldChild != null) {
					// parent to release
					if (releaseParent(parent, oldChild)) {
						// released the old child as expected
						return null;
					}
					// some parent child replaced old child. try again.
					oldChild = parent.getChild();
				} else {
					// nothing to program. Recur object as they were.
					return null;
				}
			} else {
				// add or replace old time-listener
				if (oldChild != null) {
					// replace
					if (replaceChild(parent, oldChild, newChild)) {
						// replaced as expected.
						return newChild;
					}
					// some parent child replaced old child. try again.
					oldChild = parent.getChild();
				} else {
					// add (replace if oldChild was null)
					if ((oldChild = putChildIfAbsent(parent, newChild)) == null) {
						// replaced
						return newChild;
					}
					// some parent child replaced old child. try again.
				}
			}
		}
	}
	default K computeParent(V child, BiFunction<? super V, ? super K, ? extends K> function) {
		return getChild().computeChild(child, function);
	}
	default V mergeChild(K parent, V child, BiFunction<? super V, ? super V, ? extends V> function) {
		Objects.requireNonNull(function);
		Objects.requireNonNull(child);
		V oldChild = parent.getChild();
		for (;;) {
			if (oldChild != null) {
				V newChild = function.apply(oldChild, child);
				if (newChild != null) {
					if (replaceChild(parent, oldChild, newChild))
						return newChild;
				} else if (releaseParent(parent, oldChild)) {
					return null;
				}
				oldChild = parent.getChild();
			} else {
				if ((oldChild = putChildIfAbsent(parent, child)) == null) {
					return child;
				}
			}
		}
	}
	default K mergeParent(V child, K parent, BiFunction<? super K, ? super K, ? extends K> function) {
		return getChild().mergeChild(child, parent, function);
	}
	
	//vision
	java.util.Map<K,V> inheritance();
	
	//object
    @Override
    Recursion<K,V> clone();
    
	//comparison
	@Override
	Recursion.Comparator<K,V> comparator();
	
	interface Comparator<K,V> extends TimeListener.Comparator<K,V> {
		void addParent(K parent);
		void addChild(V child);
	}
	
}